<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Photon3DotNet</name>
    </assembly>
    <members>
        <member name="T:ExitGames.Client.Photon.SimulationItem">
            <summary>
            A simulation item is an action that can be queued to simulate network lag.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.SimulationItem.stopw">
            <summary>With this, the actual delay can be measured, compared to the intended lag.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.SimulationItem.TimeToExecute">
            <summary>Timestamp after which this item must be executed.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.SimulationItem.ActionToExecute">
            <summary>Action to execute when the lag-time passed.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SimulationItem.#ctor">
            <summary>Starts a new Stopwatch</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.NetworkSimulationSet">
            <summary>
            A set of network simulation settings.
            For performance reasons, the lag and jitter settings can't be produced exactly.
            In some cases, the resulting lag will be up to 20ms bigger than the lag settings.
            Any property change will set IsSimulationEnabled to false, if all settings are 0.
            </summary>
            <remarks>
            All lag, jitter and loss is additional to the current, real network conditions.
            If the network is slow in reality, this will add even more lag.
            The jitter values will affect the lag positive and negative, so the lag settings 
            describe the medium lag even with jitter. The jitter influence is: [-jitter..+jitter].
            Packets "lost" due to OutgoingLossPercentage count for BytesOut and LostPackagesOut.
            Packets "lost" due to IncomingLossPercentage count for BytesIn and LostPackagesIn.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.isSimulationEnabled">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.outgoingLag">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.outgoingJitter">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.outgoingLossPercentage">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.incomingLag">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.incomingJitter">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.incomingLossPercentage">
            <summary>internal</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.NetworkSimulationSet.checkSimulationNeeded">
            <summary>Checks if the sum of all settings is 0 and sets isSimulationEnabled to false, if so.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IsSimulationEnabled">
            <summary>This setting overrides all other settings and turns simulation on/off. Default: false.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.OutgoingLag">
            <summary>Outgoing packages delay in ms. Default: 100.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.OutgoingJitter">
            <summary>Randomizes OutgoingLag by [-OutgoingJitter..+OutgoingJitter]. Default: 0.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.OutgoingLossPercentage">
            <summary>Percentage of outgoing packets that should be lost. Between 0..100. Default: 1. TCP ignores this setting.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IncomingLag">
            <summary>Incoming packages delay in ms. Default: 100.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IncomingJitter">
            <summary>Randomizes IncomingLag by [-IncomingJitter..+IncomingJitter]. Default: 0.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IncomingLossPercentage">
            <summary>Percentage of incoming packets that should be lost. Between 0..100. Default: 1. TCP ignores this setting.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.LostPackagesOut">
            <summary>Counts how many outgoing packages actually got lost. TCP connections ignore loss and this stays 0.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.LostPackagesIn">
            <summary>Counts how many incoming packages actually got lost. TCP connections ignore loss and this stays 0.</summary>
        </member>
        <member name="F:Photon.SocketServer.Numeric.BigInteger.DEFAULT_LEN">
            <summary>
            Default length of a BigInteger in bytes
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Numeric.BigInteger.length">
            <summary>
            The Length of this BigInteger
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Numeric.BigInteger.data">
            <summary>
            The data for this BigInteger
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.GenerateRandom(System.Int32,System.Security.Cryptography.RandomNumberGenerator)">
            <summary>
            Generates a new, random BigInteger of the specified length.
            </summary>
            <param name="bits">The number of bits for the new number.</param>
            <param name="rng">A random number generator to use to obtain the bits.</param>
            <returns>A random number of the specified length.</returns>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.GenerateRandom(System.Int32)">
            <summary>
            Generates a new, random BigInteger of the specified length using the default RNG crypto service provider.
            </summary>
            <param name="bits">The number of bits for the new number.</param>
            <returns>A random number of the specified length.</returns>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Randomize(System.Security.Cryptography.RandomNumberGenerator)">
            <summary>
            Randomizes the bits in "this" from the specified RNG.
            </summary>
            <param name="rng">A RNG.</param>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Randomize">
            <summary>
            Randomizes the bits in "this" from the default RNG.
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.TestBit(System.UInt32)">
            <summary>
            Tests if the specified bit is 1.
            </summary>
            <param name="bitNum">The bit to test. The least significant bit is 0.</param>
            <returns>True if bitNum is set to 1, else false.</returns>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Normalize">
            <summary>
                Normalizes this by setting the length to the actual number of
                uints used in data and by setting the sign to Sign.Zero if the
                value of this is 0.
            </summary>
        </member>
        <member name="T:Photon.SocketServer.Numeric.BigInteger.Kernel">
            <summary>
            Low level functions for the BigInteger
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Kernel.AddSameSign(Photon.SocketServer.Numeric.BigInteger,Photon.SocketServer.Numeric.BigInteger)">
            <summary>
            Adds two numbers with the same sign.
            </summary>
            <param name="bi1">A BigInteger</param>
            <param name="bi2">A BigInteger</param>
            <returns>bi1 + bi2</returns>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Kernel.Compare(Photon.SocketServer.Numeric.BigInteger,Photon.SocketServer.Numeric.BigInteger)">
            <summary>
            Compares two BigInteger
            </summary>
            <param name="bi1">A BigInteger</param>
            <param name="bi2">A BigInteger</param>
            <returns>The sign of bi1 - bi2</returns>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Kernel.SingleByteDivideInPlace(Photon.SocketServer.Numeric.BigInteger,System.UInt32)">
            <summary>
            Performs n / d and n % d in one operation.
            </summary>
            <param name="n">A BigInteger, upon exit this will hold n / d</param>
            <param name="d">The divisor</param>
            <returns>n % d</returns>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Kernel.Multiply(System.UInt32[],System.UInt32,System.UInt32,System.UInt32[],System.UInt32,System.UInt32,System.UInt32[],System.UInt32)">
            <summary>
            Multiplies the data in x [xOffset:xOffset+xLen] by
            y [yOffset:yOffset+yLen] and puts it into
            d [dOffset:dOffset+xLen+yLen].
            </summary>
            <remarks>
            This code is unsafe! It is the caller's responsibility to make
            sure that it is safe to access x [xOffset:xOffset+xLen],
            y [yOffset:yOffset+yLen], and d [dOffset:dOffset+xLen+yLen].
            </remarks>
        </member>
        <member name="M:Photon.SocketServer.Numeric.BigInteger.Kernel.MultiplyMod2p32pmod(System.UInt32[],System.Int32,System.Int32,System.UInt32[],System.Int32,System.Int32,System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Multiplies the data in x [xOffset:xOffset+xLen] by
            y [yOffset:yOffset+yLen] and puts the low mod words into
            d [dOffset:dOffset+mod].
            </summary>
            <remarks>
            This code is unsafe! It is the caller's responsibility to make
            sure that it is safe to access x [xOffset:xOffset+xLen],
            y [yOffset:yOffset+yLen], and d [dOffset:dOffset+mod].
            </remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.StatusCode">
            <summary>
            Enumeration of situations that change the peers internal status. 
            Used in calls to OnStatusChanged to inform your application of various situations that might happen.
            </summary>
            <remarks>
            Most of these codes are referenced somewhere else in the documentation when they are relevant to methods.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Connect">
            <summary>the PhotonPeer is connected.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Disconnect">
            <summary>the PhotonPeer just disconnected.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Exception">
            <summary>the PhotonPeer encountered an exception and will disconnect, too.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.ExceptionOnConnect">
            <summary>the PhotonPeer encountered an exception while opening the incoming connection to the server. The server could be down / not running or the client has no network or a misconfigured DNS.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.SecurityExceptionOnConnect">
            <summary>Used on platforms that throw a security exception on connect. Unity3d does this, e.g., if a webplayer build could not fetch a policy-file from a remote server.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueOutgoingReliableWarning">
            <summary>PhotonPeer outgoing queue is filling up. send more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueOutgoingUnreliableWarning">
            <summary>PhotonPeer outgoing queue is filling up. send more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.SendError">
            <summary>Sending command failed. Either not connected, or the requested channel is bigger than the number of initialized channels.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueOutgoingAcksWarning">
            <summary>PhotonPeer outgoing queue is filling up. send more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueIncomingReliableWarning">
            <summary>PhotonPeer incoming queue is filling up. Dispatch more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueIncomingUnreliableWarning">
            <summary>PhotonPeer incoming queue is filling up. Dispatch more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueSentWarning">
            <summary>PhotonPeer incoming queue is filling up. Dispatch more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.InternalReceiveException">
            <summary>Exception, if a server cannot be connected. Most likely, the server is not responding. Ask user to try again later.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TimeoutDisconnect">
            <summary>Disconnection due to a timeout (client did no longer receive ACKs from server).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServer">
            <summary>Disconnect by server due to timeout (received a disconnect command, cause server misses ACKs of client).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerUserLimit">
            <summary>Disconnect by server due to concurrent user limit reached (received a disconnect command).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerLogic">
            <summary>Disconnect by server due to server's logic (received a disconnect command).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseOk">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing is ok.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseNodeIdUnknown">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing node unknown. Check client connect values.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseEndpointUnknown">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing endpoint unknown.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseNodeNotReady">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing not setup yet. Connect again.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.EncryptionEstablished">
            <summary>(1048) Value for OnStatusChanged()-call, when the encryption-setup for secure communication finished successfully.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.EncryptionFailedToEstablish">
            <summary>(1049) Value for OnStatusChanged()-call, when the encryption-setup failed for some reason. Check debug logs.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.IPhotonPeerListener">
            <summary>
            Callback interface for the Photon client side. Must be provided to a new PhotonPeer in its constructor.
            </summary>
            <remarks>
            These methods are used by your PhotonPeer instance to keep your app updated. Read each method's
            description and check out the samples to see how to use them.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.DebugReturn(ExitGames.Client.Photon.DebugLevel,System.String)">
            <summary>
            Provides textual descriptions for various error conditions and noteworthy situations.
            In cases where the application needs to react, a call to OnStatusChanged is used.
            OnStatusChanged gives "feedback" to the game, DebugReturn provies human readable messages 
            on the background.
            </summary>
            <remarks>
            All debug output of the library will be reported through this method. Print it or put it in a 
            buffer to use it on-screen. Use PhotonPeer.DebugOut to select how verbose the output is.
            </remarks>
            <param name="level">DebugLevel (severity) of the message.</param>
            <param name="message">Debug text. Print to System.Console or screen.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnOperationResponse(ExitGames.Client.Photon.OperationResponse)">
            <summary>
            Callback method which gives you (async) responses for called operations.
            </summary>
            <remarks>
            Like methods, operations can have a result. As operation-calls are non-blocking, the response
            for any operation of this peer is provided by this method. 
            As example: Joining a room on a Lite-based server will return a list of players currently in gamey
            your actorNumber and some other values.
            
            This method is used as general callback for all operations. Each response corresponds to a certain 
            "type" of operation by its OperationCode (see: <see cref="!:Operations"/>).<para></para>
            
            The "Lite Application" uses these OpCodes:
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.Join"/> for OpJoin, contains the actorNr of "this" player
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.Leave"/> when leaving a room
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.RaiseEvent"/> for OpRaiseEvent, if this was sent as reliable command
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.SetProperties"/> for OpSetPropertiesOfActor and OpSetPropertiesOfGame
            </remarks>
            <example>
            When you join a room, the server will assign a consecutive number to each client: the 
            "actorNr" or "player number". This is sent back in the OperationResult's 
            Parameters as value of key <see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorNr"/>.<para></para>
            
            Fetch your actorNr of a Join response like this:<para></para>
            <c>int actorNr = (int)operationResponse[(byte)LiteOpKey.ActorNr];</c>
            </example>
            <param name="operationResponse">The response to an operation\-call.</param>                                                          
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnStatusChanged(ExitGames.Client.Photon.StatusCode)">
            <summary>
            OnStatusChanged is called to let the game know when asyncronous actions finished or when errors happen.
            </summary>
            <remarks>
            Not all of the many StatusCode values will apply to your game. Example: If you don't use encryption, 
            the respective status changes are never made.
            
            The values are all part of the StatusCode enumeration and described value-by-value.
            </remarks>
            <param name="statusCode">A code to identify the situation.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnEvent(ExitGames.Client.Photon.EventData)">
            <summary>
            Called whenever an event from the Photon Server is dispatched.
            </summary>
            <remarks>
            Events are used for communication between clients and allow the server to update clients over time. 
            The creation of an event is often triggered by an operation (called by this client or an other). 
            
            Each event carries its specific content in its Parameters. Your application knows which content to
            expect by checking the event's 'type', given by the event's Code.
            
            Events can be defined and extended server-side. 
            
            If you use the Lite application as base, several events like EvJoin and EvLeave are already defined.
            For these events and their Parameters, the library provides constants, so check:
            LiteEventCode and LiteEventKey classes.
            Lite also allows you to come up with custom events on the fly, purely client-side. To do so, use 
            LitePeer.OpRaiseEvent.<para></para>
            
            Events are buffered on the client side and must be Dispatched. This way, OnEvent is always taking
            place in the same thread as a <see cref="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands"/> call.
            </remarks>
            <param name="eventData">The event currently being dispatched.</param>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.Ok">
            <summary>Result code for any (internal) operation.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.ClientKey">
            <summary>Param code. Used in internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.ModeKey">
            <summary>Encryption-Mode code. Used in internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.ServerKey">
            <summary>Param code. Used in internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.InitEncryption">
            <summary>Code of internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.peerID">
            This ID is assigned by the Realtime Server upon connection. 
            The application does not have to care about this, but it is useful in debugging.                                                       
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.peerConnectionState">
            <summary>
            This is the (low level) connection state of the peer. It's internal and based on eNet's states.
            </summary>
            <remarks>Applications can read the "high level" state as PhotonPeer.PeerState, which uses a different enum.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.serverTimeOffset">
            <summary>
            The serverTimeOffset is serverTimestamp - localTime. Used to approximate the serverTimestamp with help of localTime
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.Connect(System.String,System.String,System.Byte)">
            <summary>nodeId can be ignored by implementations. TCP uses this to control the tcp-proxy</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.mtu">
            <summary> Maximum Transfer Unit to be used for UDP+TCP</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.ExchangeKeysForEncryption">
            <summary>
            Internally uses an operation to exchange encryption keys with the server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.NetworkSimRun">
            <summary>
            Core of the Network Simulation, which is available in Debug builds.
            Called by a timer in intervals.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.NetworkSimulationSettings">
            <summary>
            Gets the currently used settings for the built-in network simulation.
            Please check the description of NetworkSimulationSet for more details.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.BytesOut">
            <summary>
            Count of all bytes going out (including headers)
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.BytesIn">
            <summary>
            Count of all bytes coming in (including headers)
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.PeerBase.ConnectionStateValue">
            <summary>
            This is the replacement for the const values used in eNet like: PS_DISCONNECTED, PS_CONNECTED, etc.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Disconnected">
            <summary>No connection is available. Use connect.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Connecting">
            <summary>Establishing a connection already. The app should wait for a status callback.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Connected">
            <summary>
            The low level connection with Photon is established. On connect, the library will automatically 
            send an Init package to select the application it connects to (see also PhotonPeer.Connect()).
            When the Init is done, IPhotonPeerListener.OnStatusChanged() is called with connect.
            </summary>
            <remarks>Please note that calling operations is only possible after the OnStatusChanged() with StatusCode.Connect.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Disconnecting">
            <summary>Connection going to be ended. Wait for status callback.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.AcknowledgingDisconnect">
            <summary>Acknowledging a disconnect from Photon. Wait for status callback.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Zombie">
            <summary>Connection not properly disconnected.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.NConnect">
            <summary> Internal class to encapsulate the network i/o functionality for the realtime libary.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.NConnect.SendUdpPackage(System.Byte[],System.Int32)">
            <summary>used by PhotonPeer*</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.TConnect">
            <summary>
            Internal class to encapsulate the network i/o functionality for the realtime libary.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TConnect.sendTcp(System.Byte[])">
            <summary>
            used by TPeer*
            </summary>
            <param name="opData">
            The op Data.
            </param>
        </member>
        <member name="T:ExitGames.Client.Photon.PeerStateValue">
            <summary>
            Value range for a Peer's connection and initialization state, as returned by the PeerState property.
            </summary>
            <remarks>
            While this is not the same as the StatusCode of IPhotonPeerListener.OnStatusChanged(), it directly relates to it.
            In most cases, it makes more sense to build a game's state on top of the OnStatusChanged() as you get changes.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Disconnected">
            <summary>The peer is disconnected and can't call Operations. Call Connect().</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Connecting">
            <summary>The peer is establishing the connection: opening a socket, exchanging packages with Photon.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.InitializingApplication">
            <summary>The connection is established and now sends the application name to Photon.</summary>
            <remarks>You set the "application name" by calling PhotonPeer.Connect().</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Connected">
            <summary>The peer is connected and initialized (selected an application). You can now use operations.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Disconnecting">
            <summary>The peer is disconnecting. It sent a disconnect to the server, which will acknowledge closing the connection.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.ConnectionProtocol">
            <summary>
            These are the options that can be used as underlying transport protocol.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.ConnectionProtocol.Udp">
            <summary>Use UDP to connect to Photon, which allows you to send operations reliable or unreliable on demand.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.ConnectionProtocol.Tcp">
            <summary>Use TCP to connect to Photon.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.ConnectionProtocol.Http">
            <summary>Use HTTP connections to connect a Photon Master (not available in regular Photon SDK).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.ConnectionProtocol.Http2">
            <summary>Use HTTP connections to connect a new Photon Master (not available in regular Photon SDK).</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.DebugLevel">
            <summary>
            Level / amount of DebugReturn callbacks. Each debug level includes output for lower ones: OFF, ERROR, WARNING, INFO, ALL.
            </summary>                                                                      
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.OFF">
            <summary>No debug out.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.ERROR">
            <summary>Only error descriptions.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.WARNING">
            <summary>Warnings and errors.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.INFO">
            <summary>Information about internal workflows, warnings and errors.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.ALL">
            <summary>Most complete workflow description (but lots of debug output), info, warnings and errors.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.PhotonPeer">
            <summary>
            Instances of the PhotonPeer class are used to connect to a Photon server and communicate with it.
            </summary>
            <remarks>
            A PhotonPeer instance allows communication with the Photon Server, which in turn distributes messages
            to other PhotonPeer clients.<para></para>
            An application can use more than one PhotonPeer instance, which are treated as separate users on the
            server. Each should have its own listener instance, to separate the operations, callbacks and events.
            </remarks>                                                                                           
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonPeer.PhotonPort">
            <summary>
            The default port for Photon. DotNet and Unity3D: &quot;5055&quot;. Silverlight, using TCP: &quot;4530&quot;.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonPeer.peerCount">
            <summary>Used to assign a unique number to each peer of a process. Useful to separate debug output, etc.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonPeer.peerBase">
            <summary>Implements the message-protocol, based on the underlying network protocol (udp, tcp, http).</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,ExitGames.Client.Photon.ConnectionProtocol)">
            <summary>
            Creates a new PhotonPeer instance to communicate with Photon and selects either UDP or TCP as
            protocol. We recommend UDP.
            </summary>
            <param name="listener">a IPhotonPeerListener implementation</param>
            <param name="protocolType">Protocol to use to connect to Photon.</param>                                     
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener)">
            <summary>
            Creates a new PhotonPeer instance to communicate with Photon.<para></para>
            Connection is UDP based, except for Silverlight.
            </summary>
            <param name="listener">a IPhotonPeerListener implementation</param>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,System.Boolean)">
            <summary>
            Deprecated. Please use: PhotonPeer(IPhotonPeerListener listener, ConnectionProtocol protocolType).
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Connect(System.String,System.String)">
             <summary>
             This method does a DNS lookup (if necessary) and connects to the given serverAddress.
            
             The return value gives you feedback if the address has the correct format. If so, this 
             starts the process to establish the connection itself, which might take a few seconds.
             
             When the connection is established, a callback to IPhotonPeerListener.OnStatusChanged 
             will be done. If the connection can't be established, despite having a valid address, 
             the OnStatusChanged is called with an error-value.
            
             The applicationName defines the application logic to use server-side and it should match the name of 
             one of the apps in your server's config.
             
             By default, the applicationName is "Lite" but other samples use "LiteLobby" and "MmoDemo" in 
             Connect(). You can setup your own application and name it any way you like.
             </summary>
             <param name="serverAddress">
             Address of the Photon server. Format: ip:port (e.g. 127.0.0.1:5055) or hostname:port (e.g. localhost:5055)
             </param>
             <param name="applicationName">
             The name of the application to use within Photon or the appId of PhotonCloud.
             Should match a "Name" for an application, as setup in your PhotonServer.config.
             </param>
             <returns>
             true if IP is available (DNS name is resolved) and server is being connected. false on error.
             </returns>                                                                                         
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Connect(System.String,System.String,System.Byte)">
            <summary>
            Special version of Connect, to be used with a TCP-routing setup.
            </summary>
            <param name="serverAddress">
            Address of the Photon server. Format: ip:port (e.g. 127.0.0.1:5055) or hostname:port (e.g. localhost:5055)
            </param>
            <param name="applicationName">
            The name of the application to use within Photon or the appId of PhotonCloud.
            Should match a "Name" for an application, as setup in your PhotonServer.config.
            </param>
            <param name="node">A node of 0 does not send the routing-request. The response is provided by OnStatusChanged() and maybe a disconnect.</param>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Disconnect">
            <summary>
            This method initiates a mutual disconnect between this client and the server.
            </summary>                                                                                                                                                                               
            <remarks>
            Calling this method does not immediately close a connection. Disconnect lets the server 
            know that this client is no longer listening. For the server, this is a much faster way 
            to detect that the client is gone but it requires the client to send a few final messages.
            
            On completition, OnStatusChanged is called with the StatusCode.Disconnect.
            
            If the client is disconnected already or the connection thread is stopped, then there is no callback.
            
            Lite: The default server logic will leave any joined game and trigger the respective event 
            (<see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Leave" text="LiteEventCode.Leave"/>) for the remaining players.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.StopThread">
            <summary>
            This method immediately closes a connection (pure client side) and ends related listening Threads.
            </summary>                                                                                        
            <remarks>
            Unlike Disconnect, this method will simply stop to listen to the server. Udp connections will timeout.
            If the connections was open, this will trigger a callback to OnStatusChanged with code StatusCode.Disconnect.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.FetchServerTimestamp">
            <summary>
            This will fetch the server's timestamp and update the approximation for property ServerTimeInMilliseconds.
            
            The server time approximation will NOT become more accurate by repeated calls. Accuracy currently depends 
            on a single roundtrip which is done as fast as possible.
            
            The command used for this is immediately acknowledged by the server. This makes sure the roundtrip time is
            low and the timestamp + rountriptime / 2 is close to the original value.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.EstablishEncryption">
            <summary>
            This method creates a public key for this client and exchanges it with the server.
            </summary>
            <remarks>
            Encryption is not instantly available but calls OnStatusChanged when it finishes.
            Check for StatusCode EncryptionEstablished and EncryptionFailedToEstablish.
            
            Calling this method sets IsEncryptionAvailable to false.
            This method must be called before the "encrypt" parameter of OpCustom can be used.
            </remarks>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Service">
            <summary>
            This method excutes DispatchIncomingCommands and SendOutgoingCommands in your application Thread-context.
            </summary>
            <remarks>
            The Photon client libraries are designed to fit easily into a game or application. The application
            is in control of the context (thread) in which incoming events and responses are executed and has
            full control of the creation of UDP/TCP packages.
            
            Sending packages and dispatching received messages are two separate tasks. Service combines them
            into one method at the cost of control. It calls DispatchIncomingCommands and SendOutgoingCommands.
            
            Call this method regularly (2..20 times a second). 
            
            This will Dispatch ANY remaining buffered responses and events AND will send queued outgoing commands.
            Fewer calls might be more effective if a device cannot send many packets per second, as multiple
            operations might be combined into one package.
            </remarks>
            <example>
            You could replace Service by:
            
              while (DispatchIncomingCommands()); //Dispatch until everything is Dispatched...
              SendOutgoingCommands(); //Send a UDP/TCP package with outgoing messages
            </example>
            <seealso cref="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands"/>
            <seealso cref="M:ExitGames.Client.Photon.PhotonPeer.SendOutgoingCommands"/>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.SendOutgoingCommands">
            <summary>
            This method creates a UDP/TCP package for outgoing commands (operations and acknowledgements) 
            and sends them to the server. 
            This method is also called by Service().
            </summary>
            <remarks>
            As the Photon library does not create any UDP/TCP packages by itself. Instead, the application 
            fully controls how many packages are sent and when. A tradeoff, an application will
            lose connection, if it is no longer calling SendOutgoingCommands or Service.
            
            If multiple operations and ACKs are waiting to be sent, they will be aggregated into one
            package. The package fills in this order:
              ACKs for received commands
              A "Ping" - only if no reliable data was sent for a while
              Starting with the lowest Channel-Nr:
                Reliable Commands in channel
                Unreliable Commands in channel
            
            This gives a higher priority to lower channels.
            
            A longer interval between sends will lower the overhead per sent operation but 
            increase the internal delay (which adds "lag").
            
            Call this 2..20 times per second (depending on your target platform).
            </remarks>
            <returns>The if commands are not yet sent. Udp limits it's package size, Tcp doesnt.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands">
            <summary>
            This method directly causes the callbacks for events, responses and state changes 
            within a IPhotonPeerListener. DispatchIncomingCommands only executes a single received 
            command per call. If a command was dispatched, the return value is true and the method
            should be called again.
            This method is called by Service() until currently available commands are dispatched.
            </summary>
            <remarks>
            In general, this method should be called until it returns false. In a few cases, it might
            make sense to pause dispatching (if a certain state is reached and the app needs to load 
            data, before it should handle new events).
            
            The callbacks to the peer's IPhotonPeerListener are executed in the same thread that is
            calling DispatchIncomingCommands. This makes things easier in a game loop: Event execution
            won't clash with painting objects or the game logic.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Boolean)">
            <summary>
            Channel-less wrapper for OpCustom().
            </summary>
            <param name="customOpCode"></param>
            <param name="customOpParameters"></param>
            <param name="sendReliable"></param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Boolean,System.Byte)">
            <summary>
            Allows the client to send any operation to the Photon Server by setting any opCode and the operation's parameters. 
            </summary>
            <remarks></remarks>
            Photon can be extended with new operations which are identified by a single
            byte, defined server side and known as operation code (opCode). Similarly, the operation's parameters
            are defined server side as byte keys of values, which a client sends as customOpParameters
            accordingly.<para></para>
            This is explained in more detail as "<see cref="!:Operations" text="Custom Operations"/>".
            <param name="customOpCode">Operations are handled by their byte\-typed code. The codes of the
                                       "Lite" application are in the struct <see cref="T:ExitGames.Client.Photon.Lite.LiteOpCode"/>.</param>
            <param name="customOpParameters">A Hashtable containing parameters as key\-value pair. The key is
                                             byte\-typed, while the value is any serializable datatype.</param>
            <param name="sendReliable">Selects if the operation must be acknowledged or not. If false, the
                                       operation is not guaranteed to reach the server.</param>
            <param name="channelId">The channel in which this operation should be sent.</param>
            <returns>If operation could be enqueued for sending</returns>                                                                                                  
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Allows the client to send any operation to the Photon Server by setting any opCode and the operation's parameters. 
            </summary>
            <summary>
            Variant with encryption parameter.
            
            Use this only after encryption was established by EstablishEncryption and waiting for the OnStateChanged callback.
            </summary>
            <param name="customOpCode">Operations are handled by their byte\-typed code. The codes of the
                                       "Lite" application are in the struct <see cref="T:ExitGames.Client.Photon.Lite.LiteOpCode"/>.</param>
            <param name="customOpParameters">A Hashtable containing parameters as key\-value pair. The key is
                                             byte\-typed, while the value is any serializable datatype.</param>
            <param name="sendReliable">Selects if the operation must be acknowledged or not. If false, the
                                       operation is not guaranteed to reach the server.</param>
            <param name="channelId">The channel in which this operation should be sent.</param>
            <param name="encrypt">Can only be true, while IsEncryptionAvailable is true, too.</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(ExitGames.Client.Photon.OperationRequest,System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Allows the client to send any operation to the Photon Server by setting any opCode and the operation's parameters. 
            </summary>
            <remarks>
            Variant with an OperationRequest object.
            
            This variant offers an alternative way to describe a operation request. Operation code and it's parameters
            are wrapped up in a object. Still, the parameters are a Dictionary.
            </remarks>
            <param name="operationRequest">The operation to call on Photon.</param>
            <param name="sendReliable">Use unreliable (false) if the call might get lost (when it's content is soon outdated).</param>
            <param name="channelId">Defines the sequence of requests this operation belongs to.</param>
            <param name="encrypt">Encrypt request before sending. Depends on IsEncryptionAvailable.</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.RegisterType(System.Type,System.Byte,ExitGames.Client.Photon.SerializeMethod,ExitGames.Client.Photon.DeserializeMethod)">
            <summary>
            Registers new types/classes for de/serialization and the fitting methods to call for this type.
            </summary>
            <remarks>
            SerializeMethod and DeserializeMethod are complementary: Feed the product of serializeMethod to
            the constructor, to get a comparable instance of the object.
            
            After registering a Type, it can be used in events and operations and will be serialized like
            built-in types.
            </remarks>
            <param name="customType">Type (class) to register.</param>
            <param name="code">A byte-code used as shortcut during transfer of this Type.</param>
            <param name="serializeMethod">Method delegate to create a byte[] from a customType instance.</param>
            <param name="constructor">Method delegate to create instances of customType's from byte[].</param>
            <returns>If the Type was registered successfully.</returns>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.DebugOut">
            <summary>
            Sets the level (and amount) of debug output provided by the library. 
            </summary>                                                                                                                                                           
            <remarks>
            This affects the callbacks to IPhotonPeerListener.DebugReturn.
            Default Level: Error.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.Listener">
            <summary>
            Gets the IPhotonPeerListener of this instance (set in constructor).
            Can be used in derived classes for Listener.DebugReturn().
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.BytesIn">
            <summary>
            Gets count of all bytes coming in (including headers, excluding UDP/TCP overhead)
            </summary>                                                                  
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.BytesOut">
            <summary>
            Gets count of all bytes going out (including headers, excluding UDP/TCP overhead) 
            </summary>                                                                   
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ByteCountCurrentDispatch">
            <summary>
            Gets the size of the dispatched event or operation-result in bytes.
            This value is set before OnEvent() or OnOperationResponse() is called (within DispatchIncomingCommands()).
            </summary>
            <remarks>
            Get this value directly in OnEvent() or OnOperationResponse(). Example:
            void OnEvent(...) {
              int eventSizeInBytes = this.peer.ByteCountCurrentDispatch;
              //...
            
            void OnOperationResponse(...) {
              int resultSizeInBytes = this.peer.ByteCountCurrentDispatch;
              //...
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ByteCountLastOperation">
            <summary>
            Gets the size of the last serialized operation call in bytes.
            The value includes all headers for this single operation but excludes those of UDP, Enet Package Headers and TCP.
            </summary>
            <remarks>
            Get this value immediately after calling an operation. Example:
            this.litepeer.OpJoin("myroom");
            int opjoinByteCount = this.peer.ByteCountLastOperation;
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsEnabled">
            <summary>
            Enables the traffic statistics of a peer: TrafficStatsIncoming, TrafficStatsOutgoing and TrafficstatsGameLevel (nothing else).
            Default value: false (disabled).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsIncoming">
            <summary>
            Gets the byte-count of incoming "low level" messages, which are either Enet Commands or Tcp Messages.
            These include all headers, except those of the underlying internet protocol Udp or Tcp.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsOutgoing">
            <summary>
            Gets the byte-count of outgoing "low level" messages, which are either Enet Commands or Tcp Messages.
            These include all headers, except those of the underlying internet protocol Udp or Tcp.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsGameLevel">
            <summary>
            Gets a statistic of incoming and outgoing traffic, split by operation, operation-result and event.
            Operations are outgoing traffic, results and events are incoming.
            Includes the per-command header sizes (Udp: Enet Command Header or Tcp: Message Header).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.PeerState">
            <summary>
            This is the (low level) state of the connection to the server of a PhotonPeer.
            It is managed internally and read-only. 
            </summary>
            <remarks>
            Don't mix this up with the StatusCode provided in IPhotonListener.OnStatusChanged().
            Applications should use the StatusCode of OnStatusChanged() to track their state, as
            it also covers the higher level initialization between a client and Photon.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.PeerID">
            <summary>
            This peer's ID as assigned by the server or 0 if not using UDP. Will be 0xFFFF before the client connects.
            </summary>
            <remarks>Used for debugging only. This value is not useful in everyday Photon usage.</remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.CommandBufferSize">
            <summary>
            Initial size internal lists for incoming/outgoing commands (reliable and unreliable).
            </summary>
            <remarks>
            This sets only the initial size. All lists simply grow in size as needed. This means that
            incoming or outgoing commands can pile up and consume heap size if Service is not called 
            often enough to handle the messages in either direction.
            
            Configure the WarningSize, to get callbacks when the lists reach a certain size.
            
            UDP: Incoming and outgoing commands each have separate buffers for reliable and unreliable sending.
            There are additional buffers for &quot;sent commands&quot; and &quot;ACKs&quot;.
            TCP: Only two buffers exist: incoming and outgoing commands.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.LimitOfUnreliableCommands">
            <summary>
            Limits the queue of received unreliable commands within DispatchIncomingCommands before dispatching them.
            This works only in UDP.
            This limit is applied when you call DispatchIncomingCommands. If this client (already) received more than 
            LimitOfUnreliableCommands, it will throw away the older ones instead of dispatching them. This can produce
            bigger gaps for unreliable commands but your client catches up faster.
            </summary>
            <remarks>
            This can be useful when the client couldn't dispatch anything for some time (cause it was in a room but 
            loading a level).
            If set to 20, the incoming unreliable queues are truncated to 20.
            If 0, all received unreliable commands will be dispatched.
            This is a "per channel" value, so each channel can hold up to LimitOfUnreliableCommands commands.
            This value interacts with DispatchIncomingCommands: If that is called less often, more commands get skipped.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.QueuedIncomingCommands">
            <summary>
            Count of all currently received but not-yet-Dispatched reliable commands 
            (events and operation results) from all channels.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.QueuedOutgoingCommands">
            <summary>
            Count of all commands currently queued as outgoing, including all channels and reliable, unreliable.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ChannelCount">
            <summary>
            Gets / sets the number of channels available in UDP connections with Photon.
            Photon Channels are only supported for UDP.
            The default ChannelCount is 2.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.WarningSize">
            <summary>
            The WarningSize is used test all message queues for congestion (in and out, reliable and unreliable). 
            OnStatusChanged will be called with a warning if a queue holds WarningSize commands or a multiple 
            of it.
            Default: 100.
            Example: If command is received, OnStatusChanged will be called when the respective command queue 
            has 100, 200, 300 ... items.
            </summary>                                                                               
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.SentCountAllowance">
            <summary>
            Number of send retries before a peer is considered lost/disconnected. Default: 5.
            The initial timeout countdown of a command is calculated by the current roundTripTime + 4 * roundTripTimeVariance.
            Please note that the timeout span until a command will be resent is not constant, but based on 
            the roundtrip time at the initial sending, which will be doubled with every failed retry. 
            
            DisconnectTimeout and SentCountAllowance are competing settings: either might trigger a disconnect on the 
            client first, depending on the values and Rountrip Time.
            </summary>                                                                           
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TimePingInterval">
            <summary>
            Sets the milliseconds without reliable command before a ping command (reliable) will be sent (Default: 1000ms).
            The ping command is used to keep track of the connection in case the client does not send reliable commands 
            by itself. 
            A ping (or reliable commands) will update the RoundTripTime calculation.
            </summary>                                                                 
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.DisconnectTimeout">
            <summary>
            Milliseconds after which a reliable UDP command triggers a timeout disconnect, unless acknowledged by server.
            This value currently only affects UDP connections.
            DisconnectTimeout is not an exact value for a timeout. The exact timing of the timeout depends on the frequency
            of Service() calls and commands that are sent with long roundtrip-times and variance are checked less often for 
            re-sending!
            
            DisconnectTimeout and SentCountAllowance are competing settings: either might trigger a disconnect on the 
            client first, depending on the values and Rountrip Time.
            Default: 10000 ms.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ServerTimeInMilliSeconds">
            <summary>
            Approximated Environment.TickCount value of server (while connected).
            </summary>
            <remarks>
            UDP: The server's timestamp is automatically fetched after connecting (once). This is done 
            internally by a command which is acknowledged immediately by the server.
            TCP: The server's timestamp fetched with each ping but set only after connecting (once).
            
            The approximation will be off by +/- 10ms in most cases. Per peer/client and connection, the 
            offset will be constant (unless FetchServerTimestamp() is used). A constant offset should be 
            better to adjust for. Unfortunately there is no way to find out how much the local value 
            differs from the original.
            
            The approximation adds RoundtripTime / 2 and uses this.LocalTimeInMilliSeconds to calculate 
            in-between values (this property returns a new value per tick).
            
            The value sent by Photon equals Environment.TickCount in the logic layer (e.g. Lite).
            </remarks>
            <value>
            0 until connected.
            While connected, the value is an approximation of the server's current timestamp.
            </value>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.LocalTimeInMilliSeconds">
            <summary>
            Gets a local timestamp in milliseconds by calling the GetLocalMsTimestampDelegate.
            See LocalMsTimestampDelegate.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.LocalMsTimestampDelegate">
            <summary>
            This setter for a timestamp delegate which then replaces the default Environment.TickCount with any equal function.
            </summary>
            <remarks>
            About Environment.TickCount:
            The value of this property is derived from the system timer and is stored as a 32-bit signed integer. 
            Consequently, if the system runs continuously, TickCount will increment from zero to Int32..::.MaxValue 
            for approximately 24.9 days, then jump to Int32..::.MinValue, which is a negative number, then increment 
            back to zero during the next 24.9 days.
            </remarks>
            <exception cref="T:System.Exception">Exception is thrown peer.PeerState is not PS_DISCONNECTED.</exception>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.RoundTripTime">
            <summary>
            Time until a reliable command is acknowledged by the server.
            
            The value measures network latency and for UDP it includes the server's ACK-delay (setting in config). 
            In TCP, there is no ACK-delay, so the value is slightly lower (if you use default settings for Photon).
            
            RoundTripTime is updated constantly. Every reliable command will contribute a fraction to this value.
            
            This is also the approximate time until a raised event reaches another client or until an operation 
            result is available.
            </summary>                                                                                           
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.RoundTripTimeVariance">
            <summary>
            Changes of the roundtriptime as variance value. Gives a hint about how much the time is changing.
            </summary>                                                                                       
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TimestampOfLastSocketReceive">
            <summary>
             Stores GetLocalMsTimestamp() of the last time anything (!) was received from the server (including
             low level Ping and ACKs but also events and operation-returns). This is not the time when 
             something was dispatched.
             If you enable NetworkSimulation, this value is affected as well.
             </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ServerAddress">
            <summary>
             The server address which was used in PhotonPeer.Connect() or null (before Connect() was called).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.UsedProtocol">
            <summary>The protocol this Peer uses to connect to Photon.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.NetworkSimulationSettings">
            <summary>
            Gets the settings for built-in Network Simulation for this peer instance. 
            Once obtained, the settings can be modified by changing the properties.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.MaximumTransferUnit">
            <summary>
            The Maximum Trasfer Unit (MTU) defines the (network-level) packet-content size that is 
            guaranteed to arrive at the server in one piece. The Photon Protocol uses this
            size to split larger data into packets and for receive-buffers of packets.
            </summary>
            <remarks>
            This value affects the Packet-content. The resulting UDP packages will have additional 
            headers that also count against the package size (so it's bigger than this limit in the end)
            Setting this value while being connected is not allowed and will throw an Exception.
            Minimum is 520. Huge values won't speed up connections in most cases!
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.IsEncryptionAvailable">
            <summary>
            This property is set internally, when OpExchangeKeysForEncryption successfully finished.
            While it's true, encryption can be used for operations.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.WriteStackTrace(System.Exception,System.IO.TextWriter)">
            <summary>
            Writes the exception's stack trace to the received stream.
            </summary>
            <param name="throwable">Exception to obtain information from.</param>
            <param name="stream">Output sream used to write to.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.DictionaryToString(System.Collections.IDictionary)">
            <summary>
            This method returns a string, representing the content of the given IDictionary.
            Returns "null" if parameter is null.
            </summary>
            <param name="dictionary">IDictionary to return as string.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.NumberToByteArray(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Inserts the number's value into the byte array, using Big-Endian order (a.k.a. Network-byte-order).
            </summary>
            <param name="buffer">Byte array to write into.</param>
            <param name="index">Index of first position to write to.</param>
            <param name="number">Number to write.</param>                                                      
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.NumberToByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inserts the number's value into the byte array, using Big-Endian order (a.k.a. Network-byte-order).
            </summary>
            <param name="buffer">Byte array to write into.</param>
            <param name="index">Index of first position to write to.</param>
            <param name="number">Number to write.</param>   
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.NumberToByteArray(System.Byte[],System.Int32,System.Int64)">
            <summary>
            Inserts the number's value into the byte array, using Big-Endian order (a.k.a. Network-byte-order).
            </summary>
            <param name="buffer">Byte array to write into.</param>
            <param name="index">Index of first position to write to.</param>
            <param name="number">Number to write.</param>                                                                    
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.ByteArrayToString(System.Byte[])">
            <summary>
            Converts a byte-array to string (for debuggin output).
            </summary>
            <param name="list">Byte\-array to convert to string.</param>
            
            <returns>
            List of bytes as string (numbers separated by &quot; &quot;).
            </returns>                                                   
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.DeserializeData(System.Byte[])">
            <summary>
            Reversion function of SerializeData to restore the Hashtable of serialized data.
            </summary>
            <param name="dataBytes">A byte\-array representing a Hashtable encoded with SerializeData.</param>
            <returns>
            The Hashtable that went into SerializeData.
            </returns>                                                                                        
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.SerializeData(System.Collections.Hashtable)">
            <summary>
            Uses the internal serialization methods to create a byte-array from the data supplied.
            </summary>
            <remarks>
            This method can be helpful to save (almost) any data locally. The format uses a minimum of bytes for
            the given data.<para></para>
            You can put any information into the Hashtable as long as key and value are from the list of <see cref="!:Serializable Datatypes"/>.
            </remarks>
            <param name="data">Data Hashtable to be converted into a byte\-array.</param>
            <returns>
            Serialized data in form of a byte-array or null in case of error.
            </returns>
            <seealso cref="M:ExitGames.Client.Photon.SupportClass.DeserializeData(System.Byte[])"/>                                                                                                  
        </member>
        <member name="T:ExitGames.Client.Photon.SupportClass.ThreadSafeRandom">
            <summary>
            Class to wrap static access to the random.Next() call in a thread safe manner.
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Photon.SocketServer.Security.DiffieHellmanCryptoProvider"/> class.
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.DeriveSharedKey(System.Byte[])">
            <summary>
            Derives the shared key is generated from the secret agreement between two parties, 
            given a byte array that contains the second party's public key. 
            </summary>
            <param name="otherPartyPublicKey">
            The second party's public key.
            </param>
        </member>
        <member name="P:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.PublicKey">
            <summary>
            Gets the public key that can be used by another DiffieHellmanCryptoProvider object 
            to generate a shared secret agreement.
            </summary>
        </member>
        <member name="P:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.SharedKey">
            <summary>
             Gets the shared key that is used by the current instance for cryptographic operations.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.TrafficStatsGameLevel">
            <summary>
            Only in use as long as PhotonPeer.TrafficStatsEnabled = true;
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.OperationByteCount">
            <summary>Gets sum of outgoing operations in bytes.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.OperationCount">
            <summary>Gets count of outgoing operations.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.ResultByteCount">
            <summary>Gets sum of byte-cost of incoming operation-results.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.ResultCount">
            <summary>Gets count of incoming operation-results.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.EventByteCount">
            <summary>Gets sum of byte-cost of incoming events.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.EventCount">
            <summary>Gets count of incoming events.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalByteCount">
            <summary>Gets sum of byte-cost of all "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalMessageCount">
            <summary>Gets sum of counted "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalIncomingByteCount">
            <summary>Gets sum of byte-cost of all incoming "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalIncomingMessageCount">
            <summary>Gets sum of counted incoming "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalOutgoingByteCount">
            <summary>Gets sum of byte-cost of all outgoing "logic level" messages (= OperationByteCount).</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalOutgoingMessageCount">
            <summary>Gets sum of counted outgoing "logic level" messages (= OperationCount).</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalCount">
            <summary>Gets sum of outgoing "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.PackageHeaderSize">
            <summary>Gets the byte-size of per-package headers.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.TotalPacketBytes">
            <summary>Gets count of bytes as traffic, excluding UDP/TCP headers (42 bytes / x bytes).</summary>
        </member>
        <member name="T:Photon.SocketServer.Security.OakleyGroups">
            <summary>
            Provides classical Diffie-Hellman Modular Exponentiation Groups defined by the 
            OAKLEY Key Determination Protocol (RFC 2412).
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.Generator">
            <summary>
            Gets the genrator (N) used by the the well known groups 1,2 and 5.
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime768">
            <summary>
            Gets the 768 bit prime for the well known group 1. 
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime1024">
            <summary>
            Gets the 1024 bit prime for the well known group 2. 
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime1536">
            <summary>
            Gets the 1536  bit prime for the well known group 5. 
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.HttpBase2">
             <summary>
             Class to handle Http based connections to a Photon server.
             Requests are done asynchronous and not queued at all.
            
             All responses are put into the game's thread-context and 
             all results and state changes are done within calls of
             Service() or DispatchIncomingCommands().
             </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase2.Request(System.Byte[],System.String)">
            <summary>
            The initial request does not contain data and the UrlParameters must be "?init".
            Init returns a GUID for use in following requests as UrlParameters "?pid=GUID".
            Following requests can carry data.
            </summary>
            <param name="data"></param>
            <param name="urlParamter">The url paramters to append to the server adress uri.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase2.Request(System.Byte[],System.String,System.Boolean)">
            <param name="isDisconnect">marks the request as disconnect or "regular" request. If a disconnect is answered, change status to disconnected.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase2.ConnectAsync(System.Object)">
            <summary>Helper method to make the initial request completely async.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase2.EnqueueErrorDisconnect(ExitGames.Client.Photon.StatusCode)">
            <summary>
            Called internally when some error (or timeout) causes a disconnect. this takes care state is set and callbacks are done (once)
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.HttpBase2.PeerID">
            <summary>
            The *pid* for this peer, which is assigned by the server on connect (init).
            Initially this is Guid.Empty.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.SerializeMethod">
            <summary>
            Type of serialization methods to add custom type support.
            Use PhotonPeer.ReisterType() to register new types with serialization and deserialization methods.
            </summary>
            <param name="customObject">The method will get objects passed that were registered with it in RegisterType().</param>
            <returns>Return a byte[] that resembles the object passed in. The framework will surround it with length and type info, so don't include it.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.DeserializeMethod">
            <summary>
            Type of deserialization methods to add custom type support.
            Use PhotonPeer.RegisterType() to register new types with serialization and deserialization methods.
            </summary>
            <param name="serializedCustomObject">The framwork passes in the data it got by the associated SerializeMethod. The type code and length are stripped and applied before a DeserializeMethod is called.</param>
            <returns>Return a object of the type that was associated with this method through RegisterType().</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.OperationRequest">
            <summary>
            Container for an Operation request, which is a code and parameters.
            </summary>
            <remarks>
            On the lowest level, Photon only allows byte-typed keys for operation parameters.
            The values of each such parameter can be any serializable datatype: byte, int, hashtable and many more.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationRequest.OperationCode">
            <summary>Byte-typed code for an operation - the short identifier for the server's method to call.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationRequest.Parameters">
            <summary>The parameters of the operation - each identified by a byte-typed code in Photon.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.OperationResponse">
            <summary>
            Contains the server's request for an operation called by this peer.
            The indexer of this class actually provides access to the Parameters Dictionary.
            </summary>
            <remarks>
            The OperationCode defines the type of operation called on Photon and in turn also the Parameters that 
            are set in the request. Those are provided as Dictionary with byte-keys.
            There are pre-defined constants for various codes defined in the Lite application. Check: LiteOpCode, 
            LiteOpKey, etc.
            <para></para>
            An operation's request is summarized by the ReturnCode: a short typed code for &quot;Ok&quot; or 
            some different result. The code's meaning is specific per operation. An optional DebugMessage can be
            provided to simplify debugging.
            <para></para>
            Each call of an operation gets an ID, called the &quot;invocID&quot;. This can be matched to the IDs
            returned with any operation calls. This way, an application could track if a certain OpRaiseEvent
            call was successful.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.OperationCode">
            <summary>The code for the operation called initially (by this peer).</summary>
            <remarks>Use enums or constants to be able to handle those codes, like LiteOpCode does.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.ReturnCode">
            <summary>A code that &quot;summarizes&quot; the operation's success or failure. Specific per operation. 0 usually means "ok".</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.DebugMessage">
            <summary>An optional string sent by the server to provide readable feedback in error-cases. Might be null.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.Parameters">
            <summary>A Dictionary of values returned by an operation, using byte-typed keys per value.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.OperationResponse.ToString">
            <summary>ToString() override.</summary>
            <returns>Relatively short output of OpCode and returnCode.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.OperationResponse.ToStringFull">
            <summary>Extensive output of operation results.</summary>
            <returns>To be used in debug situations only, as it returns a string for each value.</returns>
        </member>
        <member name="P:ExitGames.Client.Photon.OperationResponse.Item(System.Byte)">
            <summary>
            Alternative access to the Parameters, which wraps up a TryGetValue() call on the Parameters Dictionary.
            </summary>
            <param name="parameterCode">The byte-code of a returned value.</param>
            <returns>The value returned by the server, or null if the key does not exist in Parameters.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.EventData">
            <summary>
            Contains all components of a Photon Event. 
            Event Parameters, like OperationRequests and OperationResults, consist of a Dictionary with byte-typed keys per value.
            </summary>
            <remarks>
            The indexer of this class actually provides access to the Parameters Dictionary.
            The operation RaiseEvent of the Lite application allows you to provide custom event content. Defined in Lite, this
            CustomContent will be made the value of key LiteEventKey.OperationRaiseEvent which is (byte)42.
            Enums and constants for the Lite-Application codes are defined in the LitePeer namespace. Check: LiteEventKey, etc.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.EventData.Code">
            <summary>The event code identifies the type of event.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ExitGames.Client.Photon.EventData.Parameters" -->
        <member name="M:ExitGames.Client.Photon.EventData.ToString">
            <summary>ToString() override.</summary>
            <returns>Short output of "Event" and it's Code.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EventData.ToStringFull">
            <summary>Extensive output of the event content.</summary>
            <returns>To be used in debug situations only, as it returns a string for each value.</returns>
        </member>
        <member name="P:ExitGames.Client.Photon.EventData.Item(System.Byte)">
            <summary>
            Alternative access to the Parameters.
            </summary>
            <param name="key">The key byte-code of a event value.</param>
            <returns>The Parameters value, or null if the key does not exist in Parameters.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.Protocol">
            <summary>
            Provides tools for the Exit Games Protocol
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.serialize(System.IO.BinaryWriter,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Calls the correct serialization method for the passed object.
            </summary>
            <param Name="serObject">Object to be serialized</param>
            <param Name="setType">If set to true, a byte describing the type is prepended.</param>
        </member>
        <member name="T:ExitGames.Client.Photon.HttpBase">
             <summary>
             Class to handle Http based connections to a Photon server.
             Requests are done asynchronous and not queued at all.
            
             All responses are put into the game's thread-context and 
             all results and state changes are done within calls of
             Service() or DispatchIncomingCommands().
             </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase.Request(System.Byte[],System.String)">
            <summary>
            The initial request does not contain data and the UrlParameters must be "?init".
            Init returns a GUID for use in following requests as UrlParameters "?pid=GUID".
            Following requests can carry data.
            </summary>
            <param name="data"></param>
            <param name="urlParamter">The url paramters to append to the server adress uri.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase.Request(System.Byte[],System.String,System.Boolean)">
            <param name="isDisconnect">marks the request as disconnect or "regular" request. If a disconnect is answered, change status to disconnected.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase.ConnectAsync">
            <summary>Helper method to make the initial request completely async.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.HttpBase.EnqueueErrorDisconnect(ExitGames.Client.Photon.StatusCode)">
            <summary>
            Called internally when some error (or timeout) causes a disconnect. this takes care state is set and callbacks are done (once)
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.HttpBase.PeerID">
            <summary>
            The *pid* for this peer, which is assigned by the server on connect (init).
            Initially this is Guid.Empty.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.EnqueueMessageAsPayload(System.Boolean,System.Byte[],System.Byte)">
            <summary>enqueues serialized operations to be sent as tcp stream / package</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.SendOutgoingCommands">
            <summary>
            gathers commands from all (out)queues until udp-packet is full and sends it!
            </summary>                                                                  
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.DispatchIncomingCommands">
            <summary>
            Checks the incoming queue and Dispatches received data if possible. Returns if a Dispatch happened or
            not, which shows if more Dispatches might be needed.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.receiveIncomingCommands(System.Byte[])">
            <summary>reads incoming tcp-packages to create and queue incoming commands*</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.SerializeOperationToMessage(System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Byte,System.Boolean,ExitGames.Client.Photon.PeerBase.EgMessageType)">
            <summary> Returns the UDP Payload starting with Magic Number for binary protocol </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.NCommand">
            <summary> Internal class for "commands" - the package in which operations are sent.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.NCommand.#ctor(ExitGames.Client.Photon.EnetPeer,System.Byte,System.Byte[],System.Byte)">
            <summary>this variant does only create outgoing commands and increments . incoming ones are created from a DataInputStream</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.NCommand.#ctor(ExitGames.Client.Photon.EnetPeer,System.IO.BinaryReader)">
            <summary>reads the command values (commandHeader and command-values) from incoming bytestream and populates the incoming command*</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteEventCode">
            <summary>
            Lite - Event codes.
            These codes are defined by the Lite application's logic on the server side.
            Other application's won't necessarily use these. 
            </summary>
            <remarks>If your game is built as extension of Lite, don't re-use these codes for your custom events.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.Join">
            <summary>(255) Event Join: someone joined the game</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.Leave">
            <summary>(254) Event Leave: someone left the game</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.PropertiesChanged">
            <summary>(253) Event PropertiesChanged</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteEventKey">
            <summary>
            Lite - Keys of event-parameters that are defined by the Lite application logic. 
            To keep things lean (in terms of bandwidth), we use byte keys to identify values in events within Photon. 
            In Lite, you can send custom events by defining a EventCode and some content. This custom content is a Hashtable,
            which can use any type for keys and values. The parameter for operation RaiseEvent and the resulting
            Events use key (byte)245 for the custom content. The constant for this is: Data or 
            <see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.CustomContent" text="LiteEventKey.CustomContent Field"/>.
            </summary>
            <remarks>
            If your game is built as extension of Lite, don't re-use these codes for your custom events.
            </remarks>                                                                                                                                                        
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorNr">
            <summary>(254) Playernumber of the player who triggered the event.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.TargetActorNr">
            <summary>(253) Playernumber of the player who is target of an event (e.g. changed properties).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorList">
            <summary>(252) List of playernumbers currently in the room.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.Properties">
            <summary>(251) Set of properties (a Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorProperties">
            <summary>(249) Key for actor (player) property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.GameProperties">
            <summary>(248) Key for game (room) property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.Data">
            <summary>(245) Custom Content of an event (a Hashtable in Lite).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.CustomContent">
            <summary>
            (245) The Lite operation RaiseEvent will place the Hashtable with your custom event-content under this key.</summary>
            <remarks>Alternative for: Data!</remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteOpCode">
            <summary>
            Lite - Operation Codes.
            This enumeration contains the codes that are given to the Lite Application's 
            operations. Instead of sending "Join", this enables us to send the byt 90.
            </summary>
            <remarks>
            Other applications (the MMO demo or your own) could define other operations and other codes.
            If your game is built as extension of Lite, don't re-use these codes for your custom events.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.Join">
            <summary>(255) Code for OpJoin, to get into a room.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.Leave">
            <summary>(254) Code for OpLeave, to get out of a room.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.RaiseEvent">
            <summary>(253) Code for OpRaiseEvent (not same as eventCode).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.SetProperties">
            <summary>(252) Code for OpSetProperties.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.GetProperties">
            <summary>(251) Operation Code for OpGetProperties.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteOpKey">
            <summary>
            Lite - keys for parameters of operation requests and responses (short: OpKey).
            </summary>
            <remarks>
            These keys match a definition in the Lite application (part of the server SDK).
            If your game is built as extension of Lite, don't re-use these codes for your custom events.
            
            These keys are defined per application, so Lite has different keys than MMO or your
            custom application. This is why these are not an enumeration.
            Lite and Lite Lobby will use the keys 255 and lower, to give you room for your own codes.
            
            Keys for operation-parameters could be assigned on a per operation basis, but
            it makes sense to have fixed keys for values which are used throughout the whole 
            application.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Asid">
            <summary>(255) Code of the room name. Used in OpJoin (Asid = Application Session ID).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.RoomName">
            <summary>(255) Code of the room name. Used in OpJoin.</summary>
            <remarks>Alternative for: Asid!</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.GameId">
            <summary>(255) Code of the game id (a unique room name). Used in OpJoin.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ActorNr">
            <summary>(254) Code of the Actor of an operation. Used for property get and set.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.TargetActorNr">
            <summary>(253) Code of the target Actor of an operation. Used for property set. Is 0 for game</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ActorList">
            <summary>(252) Code for list of players in a room. Currently not used.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Properties">
            <summary>
            (251) Code for property set (Hashtable). This key is used when sending only one set of properties.
            If either ActorProperties or GameProperties are used (of both), check those keys.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Broadcast">
            <summary>(250) Code for broadcast parameter of OpSetProperties method.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ActorProperties">
            <summary>(249) Code for property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.GameProperties">
            <summary>(248) Code for property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Cache">
            <summary>(247) Code for caching events while raising them.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ReceiverGroup">
            <summary>(246) Code to select the receivers of events (used in Lite, Operation RaiseEvent).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Data">
            <summary>(245) Code of data of an event. Used in OpRaiseEvent.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Code">
            <summary>(244) Code used when sending some code-related parameter, like OpRaiseEvent's event-code.</summary>
            <remarks>This is not the same as the Operation's code, which is no longer sent as part of the parameter Dictionary in Photon 3.</remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LitePropertyTypes">
            <summary>
            Lite - Flags for "types of properties", being used as filter in OpGetProperties.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.None">
            <summary>Flag type for no property type.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.Game">
            <summary>Flag type for game-attached properties.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.Actor">
            <summary>Flag type for actor related propeties.</summary>                       
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.GameAndActor">
            <summary>Flag type for game AND actor properties.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.EventCaching">
            <summary>
            Lite - OpRaiseEvent allows you to cache events and automatically send them to joining players in a room.
            Events are cached per event code and player: Event 100 (example!) can be stored once per player.
            Cached events can be modified, replaced and removed.
            </summary>
            <remarks>
            Caching works only combination with ReceiverGroup options Others and All.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.DoNotCache">
            <summary>Default value (not sent).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.MergeCache">
            <summary>Will merge this event's keys with those already cached.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.ReplaceCache">
            <summary>Replaces the event cache for this eventCode with this event's content.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.RemoveCache">
            <summary>Removes this event (by eventCode) from the cache.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.AddToRoomCacheGlobal">
            <summary>Adds this event to the cache for actor 0 (becoming a "globally owned" event in the cache).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.RemoveFromRoomCacheForActorsLeft">
            <summary>Removes events of players who already left the room (cleaning up).</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.ReceiverGroup">
            <summary>
            Lite - OpRaiseEvent lets you chose which actors in the room should receive events.
            By default, events are sent to "Others" but you can overrule this.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.ReceiverGroup.Others">
            <summary>Default value (not sent). Anyone else gets my event.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.ReceiverGroup.All">
            <summary>Everyone in the current room (including this peer) will get this event.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.ReceiverGroup.MasterClient">
            <summary>The server sends this event only to the actor with the lowest actorNumber.</summary>
            <remarks>The "master client" does not have special rights but is the one who is in this room the longest time.</remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LitePeer">
            <summary>
            A LitePeer is an extended PhotonPeer and implements the operations offered by the Lite Application 
            of the Photon Server SDK.
            </summary>
            <remarks>
            This class is used by our samples and allows rapid development of simple games. You can use rooms and
            properties and send events. For many games, this is a good start.
            
            Operations are prefixed as "Op" and are always asynchronous.
            </remarks>                                                                                                                                            
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener)">
            <summary>
            Creates a LitePeer instance to connect and communicate with a Photon server.<para></para>
            Uses UDP as protocol (except in the Silverlight library).
            </summary>
            <param name="listener">Your IPhotonPeerListener implementation.</param>                  
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,ExitGames.Client.Photon.ConnectionProtocol)">
            <summary>
            Creates a LitePeer instance to communicate with Photon with your selection of protocol. 
            We recommend UDP.
            </summary>
            <param name="listener">Your IPhotonPeerListener implementation.</param>
            <param name="protocolType">Protocol to use to connect to Photon.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,System.Boolean)">
            <summary>
            Deprecated. Please use: LitePeer(IPhotonPeerListener listener, ConnectionProtocol protocolType).
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Collections.Hashtable,System.Boolean)">
            <summary>
            RaiseEvent tells the server to send an event to the other players within the same room.
            </summary>
            <remarks>
            This method is described in one of its overloads.
            </remarks>
            <param name="eventCode">Identifies this type of event (and the content).</param>
            <param name="customEventContent">Custom data you want to send along.</param>
            <param name="sendReliable">If this event has to arrive at all clients.</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Collections.Hashtable,System.Boolean,System.Byte)">
             <summary>
             RaiseEvent tells the server to send an event to the other players within the same room.
             </summary>
             <remarks>
             The eventCode should be used to define the event's type and content respectively.
             The customEventContent is a Hashtable which can have any number of keys and values of the 
             <see cref="!:Serializable Datatypes" text="serializable datatypes"/>.
             Receiving clients can access this Hashtable as Parameter LiteEventKey.Data.
            
             RaiseEvent can be used reliable or unreliable. Both result in ordered events but the unreliable ones
             might be lost and allow gaps in the resulting event sequence. On the other hand, they cause less
             overhead and are optimal for data that is replaced soon. 
            
             Sending is not done immediately but when you call SendOutgoingCommands.
            
             It is recommended to keep keys (and data) as simple as possible (e.g. byte or short as key), as 
             the data is typically sent multiple times per second. This easily adds up to a huge amount of data 
             otherwise.
             </remarks>
             <example>
             <code>
             //send some position data (using byte-keys, as they are small):
             </code>
             <pre>
             <c>  Hashtable evInfo = new Hashtable();</c>
             <c>  Player local = (Player)players[playerLocalID];</c>
             <c>  evInfo.Add((byte)STATUS_PLAYER_POS_X, (Int32)local.posX);</c>
             <c>  evInfo.Add((byte)STATUS_PLAYER_POS_Y, (Int32)local.posY);</c>
             </pre>
             <code>
               peer.OpRaiseEvent(EV_MOVE, evInfo, true);  //EV_MOVE = (byte)101
             
             //receive this custom event in OnEvent():
               Hashtable data = (Hashtable)photonEvent[LiteEventKey.Data];
               switch (eventCode) {
                 case EV_MOVE:               //101 in this sample
                     p = (Player)players[actorNr];
                     if (p != null) {
                         p.posX = (int)data[(byte)STATUS_PLAYER_POS_X];
                         p.posY = (int)data[(byte)STATUS_PLAYER_POS_Y];
                     }
                     break;
             </code>
             
             Events from the Photon Server received and internally buffered until 
             they are <see cref="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands" text="Dispatched"/>.
             </example>
             <param name="eventCode">Identifies this type of event (and the content).</param>
             <param name="customEventContent">Custom data you want to send along.</param>
             <param name="sendReliable">If this event has to arrive at all clients.</param>
             <param name="channelId">Number of channel to use (starting with 0).</param>
             <returns>If operation could be enqueued for sending.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Collections.Hashtable,System.Boolean,System.Byte,System.Int32[])">
            <summary>
            RaiseEvent tells the server to send an event to the other players within the same room.
            </summary>
            <remarks>
            This method is described in one of its overloads.
            
            This variant has an optional list of targetActors. Use this to send the event only to
            specific actors in the same room. 
            This can be useful to implement private messages inside a room or similar.
            </remarks>
            <param name="eventCode">Identifies this type of event (and the content).</param>
            <param name="customEventContent">Custom data you want to send along.</param>
            <param name="sendReliable">If this event has to arrive at all clients.</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <param name="targetActors">List of actorNumbers that receive this event.</param>
            <returns>If operation could be enqueued for sending.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Collections.Hashtable,System.Boolean,System.Byte,ExitGames.Client.Photon.Lite.EventCaching,ExitGames.Client.Photon.Lite.ReceiverGroup)">
            <summary>
            Calls operation RaiseEvent on the server, with full control of event-caching and the target receivers.
            </summary>
            <remarks>
            This method is described in one of its overloads.
            
            The cache parameter defines if and how this event will be cached server-side. Per event-code, your client
            can store events and update them and will send cached events to players joining the same room.
            
            The option EventCaching.DoNotCache matches the default behaviour of RaiseEvent.
            The option EventCaching.MergeCache will merge the costomEventContent into existing one. 
            Values in the customEventContent Hashtable can be null to remove existing values.
            
            With the receivers parameter, you can chose who gets this event: Others (default), All (includes you as sender)
            or MasterClient. The MasterClient is the connected player with the lowest ActorNumber in this room.
            This player could get some privileges, if needed.
            
            Read more about Cached Events in the DevNet: http://developer.exitgames.com
            </remarks>
            <param name="eventCode">Identifies this type of event (and the content).</param>
            <param name="customEventContent">Custom data you want to send along.</param>
            <param name="sendReliable">If this event has to arrive at all clients.</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <param name="cache">Events can be cached (merged and removed) for players joining later on.</param>
            <param name="receivers">Controls who should get this event.</param>
            <returns>If operation could be enqueued for sending.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpSetPropertiesOfActor(System.Int32,System.Collections.Hashtable,System.Boolean,System.Byte)">
            <summary>
            Attaches or updates properties of the specified actor.
            </summary>
            <remarks>
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">hashtable containing the properties to add or overwrite</param>
            <param name="actorNr">the actorNr is used to identify a player/peer in a game</param>
            <param name="broadcast">true will trigger an event LiteEventKey.PropertiesChanged with the updated
                                    properties in it</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpSetPropertiesOfGame(System.Collections.Hashtable,System.Boolean,System.Byte)">
            Please read the general description of <see cref="!:Properties on Photon"/>.
            <summary>
            Attaches or updates properties of the current game.
            </summary>
            <param name="properties">hashtable containing the properties to add or overwrite</param>
            <param name="broadcast">true will trigger an event LiteEventKey.PropertiesChanged with the updated
                                    properties in it</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetProperties(System.Byte)">
            <summary>
            Gets all properties of the game and each actor.
            </summary>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfActor(System.Int32[],System.String[],System.Byte)">
            Please read the general description of <see cref="!:Properties on Photon"/>.
            <summary>
            Gets selected properties of an actor.
            </summary>
            <param name="properties">optional, array of property keys to fetch</param>
            <param name="actorNrList">optional, a list of actornumbers to get the properties of</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfActor(System.Int32[],System.Byte[],System.Byte)">
            Please read the general description of <see cref="!:Properties on Photon"/>.
            <summary>
            Gets selected properties of an actor.
            </summary>
            <param name="properties">optional, array of property keys to fetch</param>
            <param name="actorNrList">optional, a list of actornumbers to get the properties of</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfGame(System.String[],System.Byte)">
            Please read the general description of <see cref="!:Properties on Photon"/>.
            <summary>
            Gets selected properties of current game.
            </summary>
            <param name="properties">array of property keys to fetch</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfGame(System.Byte[],System.Byte)">
            Please read the general description of <see cref="!:Properties on Photon"/>.
            <summary>
            Gets selected properties of current game.
            </summary>
            <param name="properties">array of property keys to fetch</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>                                                                                  
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpJoin(System.String)">
             <summary>
             This operation will join an existing room by name or create one if the name is not in use yet.
             
             Rooms (or games) are simply identified by name. We assume that users always want to get into a room - no matter 
             if it existed before or not, so it might be a new one. If you want to make sure a room is created (new, empty),
             the client side might come up with a unique name for it (make sure the name was not taken yet). 
            
             The application "Lite Lobby" lists room names and effectively allows the user to select a distinct one.
             
             Each actor (a.k.a. player) in a room will get events that are raised for the room by any player. 
             
             To distinguish the actors, each gets a consecutive actornumber. This is used in events to mark who triggered 
             the event. A client finds out it's own actornumber in the return callback for operation Join. Number 1 is the 
             lowest actornumber in each room and the client with that actornumber created the room.
             
             Each client could easily send custom data around. If the data should be available to newcomers, it makes sense
             to use Properties.
             
             Joining a room will trigger the event <see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Join" text="LiteEventCode.Join"/>, which contains 
             the list of actorNumbers of current players inside the  room 
             (<see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorList" text="LiteEventKey.ActorList"/>). This also gives you a count of current
             players.
             </summary>
             <param name="gameName">Any identifying name for a room / game.</param>
             <returns>If operation could be enqueued for sending</returns>                                                                                                                                                      
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpJoin(System.String,System.Collections.Hashtable,System.Collections.Hashtable,System.Boolean)">
             <summary>
             This operation will join an existing room by name or create one if the name is not in use yet.
             
             Rooms (or games) are simply identified by name. We assume that users always want to get into a room - no matter 
             if it existed before or not, so it might be a new one. If you want to make sure a room is created (new, empty),
             the client side might come up with a unique name for it (make sure the name was not taken yet). 
            
             The application "Lite Lobby" lists room names and effectively allows the user to select a distinct one.
             
             Each actor (a.k.a. player) in a room will get events that are raised for the room by any player. 
             
             To distinguish the actors, each gets a consecutive actornumber. This is used in events to mark who triggered 
             the event. A client finds out it's own actornumber in the return callback for operation Join. Number 1 is the 
             lowest actornumber in each room and the client with that actornumber created the room.
             
             Each client could easily send custom data around. If the data should be available to newcomers, it makes sense
             to use Properties.
             
             Joining a room will trigger the event <see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Join" text="LiteEventCode.Join"/>, which contains 
             the list of actorNumbers of current players inside the  room 
             (<see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorList" text="LiteEventKey.ActorList"/>). This also gives you a count of current
             players.
             </summary>
             
             <param name="gameName">Any identifying name for a room / game.</param>
             <param name="gameProperties">optional, set of game properties, by convention: only used if game is new/created</param>
             <param name="actorProperties">optional, set of actor properties</param>
             <param name="broadcastActorProperties">optional, broadcast actor proprties in join-event</param>
             <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpLeave">
            <summary>
            Leave operation of the Lite Application (also in Lite Lobby).
            Leaves a room / game, but keeps the connection. This operations triggers the event <see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Leave" text="LiteEventCode.Leave"/>
            for the remaining clients. The event includes the actorNumber of the player who left in key <see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorNr" text="LiteEventKey.ActorNr"/>.
            </summary>
            <returns>
            Consecutive invocationID of the OP. Will throw Exception if not connected.
            </returns>                                                                                                                                                                                    
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.channels">
            <summary>Will contain channel 0xFF and any other.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.sentReliableCommands">
            <summary>One list for all channels keeps sent commands (for re-sending).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.outgoingAcknowledgementsList">
            <summary>One list for all channels keeps acknowledgements.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.CreateAndEnqueueCommand(System.Byte,System.Byte[],System.Byte)">
            <summary>reliable-udp-level function to send some byte[] to the server via un/reliable command</summary>
            <remarks>only called when a custom operation should be send</remarks>
            <param name="commandType">(enet) command type</param>
            <param name="payload">data to carry (operation)</param>
            <param name="channelNumber">channel in which to send</param>
            <returns>the invocation ID for this operation (the payload)</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.EnqueueOperation(System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Byte,System.Boolean,System.Byte,System.Boolean,ExitGames.Client.Photon.PeerBase.EgMessageType)">
            <summary>
            Checks connected state and channel before operation is serialized and enqueued for sending.
            </summary>
            <param name="parameters">operation parameters</param>
            <param name="opCode">code of operation</param>
            <param name="sendReliable">send as reliable command</param>
            <param name="channelId">channel (sequence) for command</param>
            <param name="encrypt">encrypt or not</param>
            <param name="messageType">usually EgMessageType.Operation</param>
            <returns>if operation could be enqueued</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SendOutgoingCommands">
            <summary>
            gathers commands from all (out)queues until udp-packet is full and sends it!
            </summary>                                                                  
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands">
            <summary>
            Checks the incoming queue and Dispatches received data if possible. Returns if a Dispatch happened or
            not, which shows if more Dispatches might be needed.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.receiveIncomingCommands(System.Byte[])">
            <summary>reads incoming udp-packages to create and queue incoming commands*</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.queueIncomingCommand(ExitGames.Client.Photon.NCommand)">
            <summary>queues incoming commands in the correct order as either unreliable, reliable or unsequenced. return value determines if the command is queued / done.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.removeSentReliableCommand(System.Int32,System.Int32)">
            <summary>removes commands which are acknowledged*</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SerializeOperationToMessage(System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Byte,System.Boolean,ExitGames.Client.Photon.PeerBase.EgMessageType)">
            <summary> Returns the UDP Payload starting with Magic Number for binary protocol </summary>
        </member>
    </members>
</doc>
